<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resume Service Metadata Population Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
        }
        h3 {
            color: #c0392b;
            margin-top: 25px;
        }
        .summary-box {
            background: #fdf2f2;
            padding: 20px;
            border-radius: 5px;
            border-left: 5px solid #e74c3c;
            margin: 20px 0;
        }
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
        }
        .flow-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            font-family: monospace;
            margin: 20px 0;
            border: 1px solid #dee2e6;
        }
        .benefits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .benefit-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .benefit-card h4 {
            color: #c0392b;
            margin-top: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #dee2e6;
        }
        th {
            background-color: #e74c3c;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .icon-demo {
            font-size: 1.5em;
            margin-right: 10px;
        }
        .new-feature {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .enhancement-badge {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: bold;
        }
        .highlight-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        .step-indicator {
            display: inline-block;
            background: #e74c3c;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-weight: bold;
            margin-right: 10px;
        }
        .location-tag {
            background: #17a2b8;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .timing-tag {
            background: #ffc107;
            color: #212529;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        ul li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Resume Service Metadata Population Guide <span class="enhancement-badge">v1.0</span></h1>

        <div class="summary-box">
            <h2>Executive Summary</h2>
            <p>This guide explains <strong>when and where</strong> all metadata fields get populated in your Resume Service architecture. Instead of overwhelming you with complex interfaces, this focuses on the practical data flow and implementation points where each piece of metadata is actually created and populated.</p>
        </div>

        <div class="highlight-box">
            <p><strong>üéØ Key Point:</strong> You don't manually populate most metadata - it gets generated automatically based on what happens during each request lifecycle. This guide shows you exactly where that happens.</p>
        </div>

        <h2>üìä Metadata Population Flow</h2>

        <h3>Current Simple Structure</h3>
        <div class="code-block">
// Your current interfaces.ts - KEEP IT SIMPLE!
import type { MetaResponse } from "~/api/interfaces";

export interface ResumeMeta extends MetaResponse {}
export interface ExperienceMeta extends MetaResponse {}
export interface SkillMeta extends MetaResponse {}
export interface EducationMeta extends MetaResponse {}

// MetaResponse should contain only the essentials:
export interface MetaResponse {
  total: number;           // ‚Üê Populated after data fetch
  cacheHit: boolean;       // ‚Üê Populated during cache check
  source: 'api' | 'cache'; // ‚Üê Populated based on data source
  correlationId: string;   // ‚Üê Populated at request start
  requestDuration?: number; // ‚Üê Populated at request end (optional)
}
        </div>

        <h2>üîÑ Step-by-Step Data Flow</h2>

        <div class="benefits-grid">
            <div class="benefit-card">
                <h4><span class="step-indicator">1</span>Request Initiation</h4>
                <p><span class="location-tag">Component/Hook</span> <span class="timing-tag">Start</span></p>
                <div class="code-block">
// app/hooks/useSkills.ts
const correlationId = `skills-${Date.now()}`;
const request = { params: { limit: 50 } };

// ‚úÖ Step 1 Fields Populated:
// - correlationId ‚Üê Generated here
                </div>
            </div>

            <div class="benefit-card">
                <h4><span class="step-indicator">2</span>Performance Tracking</h4>
                <p><span class="location-tag">Service Layer</span> <span class="timing-tag">Start</span></p>
                <div class="code-block">
// app/service/resume/resume-service.ts
const startTime = performance.now();

// ‚úÖ Step 2 Fields Populated:
// - startTime ‚Üê Captured for duration calc
                </div>
            </div>

            <div class="benefit-card">
                <h4><span class="step-indicator">3</span>Cache Check</h4>
                <p><span class="location-tag">Service Layer</span> <span class="timing-tag">Mid-Request</span></p>
                <div class="code-block">
// Cache check logic
const cached = this.cache.get(cacheKey);
if (cached) {
  // ‚úÖ Step 3a Fields Populated:
  // - cacheHit ‚Üê true
  // - source ‚Üê 'cache'
  // - total ‚Üê cached.data.length
}
                </div>
            </div>

            <div class="benefit-card">
                <h4><span class="step-indicator">4</span>API Call</h4>
                <p><span class="location-tag">Service Layer</span> <span class="timing-tag">Mid-Request</span></p>
                <div class="code-block">
// API call when no cache
const response = await this.apiClient.get('/api/skills');

// ‚úÖ Step 4 Fields Populated:
// - cacheHit ‚Üê false
// - source ‚Üê 'api'
// - total ‚Üê response.data.length
                </div>
            </div>

            <div class="benefit-card">
                <h4><span class="step-indicator">5</span>Response Assembly</h4>
                <p><span class="location-tag">Service Layer</span> <span class="timing-tag">End</span></p>
                <div class="code-block">
// Final response building
const endTime = performance.now();

return {
  target: data,
  meta: {
    total: data.length,          // ‚Üê From data array
    cacheHit: fromCache,         // ‚Üê From cache check
    source: dataSource,          // ‚Üê From data source
    correlationId: requestId,    // ‚Üê From step 1
    requestDuration: endTime - startTime // ‚Üê Calculated
  },
  error: null
};
                </div>
            </div>

            <div class="benefit-card">
                <h4><span class="step-indicator">6</span>Telemetry Tracking</h4>
                <p><span class="location-tag">Service Layer</span> <span class="timing-tag">End</span></p>
                <div class="code-block">
// AI Tracing integration
this.telemetryService.trackEvent({
  name: 'SkillsDataLoaded',
  properties: {
    correlationId: meta.correlationId,
    skillCount: meta.total.toString(),
    cacheHit: meta.cacheHit.toString(),
    duration: meta.requestDuration
  }
});
                </div>
            </div>
        </div>

        <h2>üèóÔ∏è Practical Implementation</h2>

        <h3>Minimal Working Service Method</h3>
        <div class="new-feature">
            <p><strong>Start Here:</strong> This is all you need to implement for your service method to populate metadata correctly.</p>
        </div>

        <div class="code-block">
// app/service/resume/resume-service.ts
class ResumeService extends BaseDataService {
  async getSkills(request: SkillRequest, correlationId?: string): Promise<ApiDataResponse<Skill, SkillMeta>> {
    // üïê Step 1: Start timing & correlation
    const startTime = performance.now();
    const requestId = correlationId || `skills-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    
    try {
      // üóÇÔ∏è Step 2: Check cache (determines cacheHit & source)
      const cacheKey = this.buildCacheKey('skills', request.params);
      const cached = this.cache.get(cacheKey);
      
      if (cached) {
        // ‚úÖ Cache Hit Path - Metadata populated automatically
        return {
          target: cached.data,
          meta: {
            total: cached.data.length,           // ‚Üê Auto: from cached data
            cacheHit: true,                      // ‚Üê Auto: cache path taken
            source: 'cache',                     // ‚Üê Auto: cache source
            correlationId: requestId,            // ‚Üê Auto: from request start
            requestDuration: performance.now() - startTime  // ‚Üê Auto: calculated
          } as SkillMeta,
          error: null
        };
      }

      // üåê Step 3: API call (determines different metadata values)
      const response = await this.apiClient.get('/api/skills', {
        params: request.params,
        headers: { 'X-Correlation-ID': requestId }
      });

      // üíæ Step 4: Cache the result for future requests
      this.cache.set(cacheKey, { data: response.data, timestamp: Date.now() });

      // üìä Step 5: Build response with API metadata
      const endTime = performance.now();
      const result = {
        target: response.data,
        meta: {
          total: response.data.length,         // ‚Üê Auto: from API response
          cacheHit: false,                     // ‚Üê Auto: API path taken
          source: 'api',                       // ‚Üê Auto: API source
          correlationId: requestId,            // ‚Üê Auto: from request start
          requestDuration: endTime - startTime // ‚Üê Auto: calculated timing
        } as SkillMeta,
        error: null
      };

      // üìà Step 6: Send telemetry (optional but recommended)
      this.businessTracker.trackSkillsLoaded({
        count: result.meta.total,
        cacheHit: result.meta.cacheHit,
        correlationId: result.meta.correlationId,
        source: result.meta.source
      });

      return result;

    } catch (error) {
      // ‚ùå Error Path - Still populate metadata
      return {
        target: [],
        meta: {
          total: 0,                            // ‚Üê Auto: no data on error
          cacheHit: false,                     // ‚Üê Auto: error path
          source: 'api',                       // ‚Üê Auto: attempted API call
          correlationId: requestId,            // ‚Üê Auto: from request start
          requestDuration: performance.now() - startTime  // ‚Üê Auto: error timing
        } as SkillMeta,
        error: error.message                   // ‚Üê Auto: error message
      };
    }
  }

  // üîß Helper method for cache key generation
  private buildCacheKey(endpoint: string, params: any): string {
    return `${endpoint}-${JSON.stringify(params)}`;
  }

  // üÜî Helper method for correlation ID generation
  private generateCorrelationId(): string {
    return `resume-service-${Date.now()}-${Math.random().toString(36).substr(2, 8)}`;
  }
}
        </div>

        <h2>üìã Metadata Field Reference</h2>

        <table>
            <thead>
                <tr>
                    <th>Field</th>
                    <th>When Populated</th>
                    <th>Where Populated</th>
                    <th>Example Value</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>total</strong></td>
                    <td>After data fetch</td>
                    <td>Service method response building</td>
                    <td><code>15</code></td>
                    <td>Count of returned items</td>
                </tr>
                <tr>
                    <td><strong>cacheHit</strong></td>
                    <td>During cache check</td>
                    <td>Service method cache logic</td>
                    <td><code>true/false</code></td>
                    <td>Performance analysis</td>
                </tr>
                <tr>
                    <td><strong>source</strong></td>
                    <td>Based on data origin</td>
                    <td>Service method data path</td>
                    <td><code>'cache'/'api'</code></td>
                    <td>Data provenance tracking</td>
                </tr>
                <tr>
                    <td><strong>correlationId</strong></td>
                    <td>Request initiation</td>
                    <td>Hook/Component or Service</td>
                    <td><code>'skills-1642123456-a1b2c'</code></td>
                    <td>Request tracing across services</td>
                </tr>
                <tr>
                    <td><strong>requestDuration</strong></td>
                    <td>Request completion</td>
                    <td>Service method timing logic</td>
                    <td><code>145</code> (milliseconds)</td>
                    <td>Performance monitoring</td>
                </tr>
            </tbody>
        </table>

        <h2>üéØ Implementation Priority</h2>

        <div class="flow-diagram">
Priority 1: Essential Fields (Start Here)
‚îú‚îÄ‚îÄ total          ‚Üê response.data.length
‚îú‚îÄ‚îÄ correlationId  ‚Üê generated at request start
‚îî‚îÄ‚îÄ error          ‚Üê error.message (if error occurs)

Priority 2: Performance Tracking
‚îú‚îÄ‚îÄ cacheHit       ‚Üê determined during cache check
‚îú‚îÄ‚îÄ source         ‚Üê 'cache' | 'api' based on data path
‚îî‚îÄ‚îÄ requestDuration‚Üê performance.now() difference

Priority 3: Enhanced Telemetry (Later)
‚îú‚îÄ‚îÄ Custom metrics per entity type
‚îú‚îÄ‚îÄ User behavior tracking
‚îî‚îÄ‚îÄ Advanced performance analytics
        </div>

        <h2>üîç Common Implementation Patterns</h2>

        <h3>Pattern 1: Cache-First Strategy</h3>
        <div class="code-block">
// Standard cache-first implementation
async getData(request, correlationId) {
  const startTime = performance.now();
  
  // Check cache first
  const cached = this.cache.get(key);
  if (cached) {
    return this.buildResponse(cached.data, {
      cacheHit: true,
      source: 'cache',
      correlationId,
      startTime
    });
  }
  
  // Fallback to API
  const apiData = await this.apiClient.get(url);
  this.cache.set(key, apiData);
  
  return this.buildResponse(apiData.data, {
    cacheHit: false,
    source: 'api',
    correlationId,
    startTime
  });
}
        </div>

        <h3>Pattern 2: Error Handling with Metadata</h3>
        <div class="code-block">
// Error handling that still populates metadata
try {
  // ... normal flow
} catch (error) {
  // Still return structured response with metadata
  return {
    target: [],
    meta: {
      total: 0,
      cacheHit: false,
      source: 'api', // Attempted source
      correlationId,
      requestDuration: performance.now() - startTime
    },
    error: error.message // ‚Üê Key: Error captured here
  };
}
        </div>

        <h3>Pattern 3: Response Building Helper</h3>
        <div class="code-block">
// Reusable response builder to ensure consistency
private buildResponse<T>(data: T[], options: {
  cacheHit: boolean;
  source: 'cache' | 'api';
  correlationId: string;
  startTime: number;
  error?: string;
}): ApiDataResponse<T, MetaResponse> {
  return {
    target: data,
    meta: {
      total: data.length,
      cacheHit: options.cacheHit,
      source: options.source,
      correlationId: options.correlationId,
      requestDuration: performance.now() - options.startTime
    },
    error: options.error || null
  };
}
        </div>

        <h2>üöÄ Next Steps</h2>

        <div class="benefits-grid">
            <div class="benefit-card">
                <h4><span class="icon-demo">1Ô∏è‚É£</span>Start Simple</h4>
                <ul>
                    <li>Implement <strong>one service method</strong> with basic metadata</li>
                    <li>Focus on <code>total</code>, <code>correlationId</code>, <code>error</code></li>
                    <li>Test the flow end-to-end</li>
                    <li>Verify metadata appears in responses</li>
                </ul>
            </div>

            <div class="benefit-card">
                <h4><span class="icon-demo">2Ô∏è‚É£</span>Add Performance</h4>
                <ul>
                    <li>Add timing with <code>performance.now()</code></li>
                    <li>Implement cache checking logic</li>
                    <li>Populate <code>cacheHit</code> and <code>source</code> fields</li>
                    <li>Test cache hit/miss scenarios</li>
                </ul>
            </div>

            <div class="benefit-card">
                <h4><span class="icon-demo">3Ô∏è‚É£</span>Enhance Gradually</h4>
                <ul>
                    <li>Add telemetry tracking calls</li>
                    <li>Implement entity-specific metadata</li>
                    <li>Add Azure Application Insights integration</li>
                    <li>Build monitoring dashboards</li>
                </ul>
            </div>
        </div>

        <div class="summary-box">
            <h2>Key Takeaway</h2>
            <p><strong>Metadata Population is Automatic:</strong> You don't manually create most metadata values. They get populated automatically based on what happens during each request - cache hits, API calls, timing, errors, etc. The service layer handles this transparently as part of processing each request.</p>
            
            <p><strong>Start with the essentials:</strong> <code>total</code>, <code>correlationId</code>, and <code>error</code>. Add performance tracking (<code>cacheHit</code>, <code>source</code>, <code>requestDuration</code>) once the basic flow works. Enhanced telemetry and entity-specific metadata can come later.</p>
        </div>
    </div>
</body>
</html>